#!/bin/bash
#
# Routing Setup Functions
# Copyright (C) 2012 by Thomas Dreibholz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: dreibh@simula.no
#


# NOTE:
# Only 8 TOS field settings allowed (remaining bits masked out!)
# This is a bug in the Linux kernel!
# T0 -> 0x00
# T1 -> 0x04
# T2 -> 0x08
# T3 -> 0x0C
# T4 -> 0x10
# T5 -> 0x14
# T6 -> 0x18
# T7 -> 0x1C


# ###### Write log information ##############################################
log ()
{
   echo -e "\x1b[34m`date --utc --iso-8601=s`: $@\x1b[0m"
}


# ###### Write log action information #######################################
log-action ()
{
   echo -en "\x1b[34m`date --utc --iso-8601=s`: $@\x1b[0m"
}


# ###### Write log result information #######################################
log-result ()
{
   local result="$1"
   local line=128

   if [ "$result" = "1" ] ; then
      echo -en "\x1b[${line}G\x1b[32mOK\x1b[0m\n"
   elif [ "$result" = "0" ] ; then
      echo -en "\x1b[${line}G\x1b[30;47;5mFAILED!\x1b[0m\n"
   else
      echo -en "\x1b[${line}G\x1b[0m$result\n"
   fi
}


# ###### Tunnel removal #####################################################
remove-tunnel ()
{
   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local tunnelKey="$2"           # Tunnel key, must be unique between sites

   ip tunnel del $interface 2>/dev/null || true
}


# ###### Tunnel setup #######################################################
make-tunnel ()
{
   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local tunnelKey="$2"           # Tunnel key, must be unique between sites
   local outerLocalIP="$3"        # Outer Local IP
   local outerRemoteIP="$4"       # Outer Remote IP
   local innerLocalIP="$5"        # Inner Local IP
   local innerRemoteIP="$6"       # Inner Remote IP
   local miscOptions="$7"         # Further options

   local innerV6option=""
   local outerV6option=""
   if [[ "$innerLocalIP" =~ : ]] ; then
      innerV6option="-6"
   fi
   if [[ "$outerLocalIP" =~ : ]] ; then
      outerV6option="-6"
   fi

   local mode=""
   local greoption=""
   if [[ "$interface" =~ ^seks ]] ; then
      mode="any"
   elif [[ "$interface" =~ ^fire ]] ; then
      mode="sit"
   elif [[ "$interface" =~ ^gre ]] ; then
      mode="gre"
      greoption="key $tunnelKey"
   else
      echo >&2 "ERROR: Cannot determine tunnel mode from interface name $interface!"
      exit 1
   fi

   local addToExistingTunnel=0
   if [[ "$miscOptions" =~ --add-to-existing-tunnel ]] ; then
      addToExistingTunnel=1
   fi

   # ====== Tunnel setup ====================================================
   # Create the tunnel
   if [ $addToExistingTunnel -eq 0 ] ; then
      remove-tunnel "$interface" "$tunnelKey" "$from" "$tos" "$fwmark"
      ip $outerV6option tunnel add $interface mode $mode local $outerLocalIP remote $outerRemoteIP ttl 255 $greoption  $tunnelOptions
   fi
   # Configure an address and turn the interface up
   if [ "$innerV6option" = "" ] ; then
      ip addr add $innerLocalIP peer $innerRemoteIP dev $interface
   else
      ip $innerV6option addr add $innerLocalIP/64 dev $interface
   fi
   ip link set dev $interface up
   # Turn off Reverse Path filtering, since it prevents routing packets
   # from interface when this interface has no route to the source!
   sysctl -q net.ipv4.conf.$interface.rp_filter=0
   # Also, turn off Reverse Path filter on all interfaces.
   # If it is turned on, it supersedes all per-interface settings!
   sysctl -q net.ipv4.conf.all.rp_filter=0

   # echo "$interface: tunnel [$innerLocalIP <-> $innerRemoteIP] via [$outerLocalIP <-> $outerRemoteIP]"
}


# ###### Check tunnel #######################################################
show-tunnel ()
{
   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local innerLocalIP="$2"        # Inner Local IP
   local innerRemoteIP="$3"       # Inner Remote IP
   local description="$4"         # Description

   # echo -en "Pinging $innerRemoteIP (peer of tunnel interface $interface) ..."

   if [[ "$innerRemoteIP" =~ : ]] ; then
      ping6 -W3 -c3 -i0.2 -q $innerRemoteIP -I $innerLocalIP >/dev/null 2>&1 && log-result 1 || log-result 0
   else
      ping -W3 -c3 -i0.2 -q $innerRemoteIP -I $innerLocalIP >/dev/null 2>&1 && log-result 1 || log-result 0
   fi
}


# ###### Routing table removal ##############################################
remove-table ()
{
   local tableID="$1"             # Table ID

   # ====== Remove routing table ============================================
   ip route flush table $1

   # ====== Remove all rules pointing to that table =========================
   ip rule show | (
     while read inputLine ; do
         if [[ $inputLine =~ ([0-9]*):(.*)([ \t]*lookup ${tableID}[ \t]*)$ ]]; then
            if [ ${#BASH_REMATCH[*]} -eq 4 ] ; then
               pref=${BASH_REMATCH[1]}
               rule=${BASH_REMATCH[2]}
               lookup=${BASH_REMATCH[3]}

               echo ip rule del $rule lookup ${lookup} pref $pref
               ip rule del $rule ${lookup} pref $pref
            fi
        fi
     done
   )
}


# ###### Routing table setup ################################################
make-table ()
{
   local tableID="$1"             # Table ID

   remove-table $tableID
}


# ###### Add selector for routing table #####################################
add-table-selector ()
{
   local tableID="$1"             # Table ID
   local preference="$2"          # Selected preference
   shift ; shift

   local v6option=""
   local selectorOptions=""
   while [ "$1" != "" ] ; do
      if [ "$1" = "from" ] ; then
         selectorOptions="$selectorOptions from $2"
         if [[ "$2" =~ : ]] ; then
            v6option="-6"
         fi
         shift
      elif [ "$1" = "tos" ] ; then
         selectorOptions="$selectorOptions tos $2"
         shift
      elif [ "$1" = "fwmark" ] ; then
         selectorOptions="$selectorOptions fwmark $2"
         shift
      fi
      shift
   done

   # echo ip $v6option rule add $selectorOptions lookup $tableID pref $preference
   ip $v6option rule add $selectorOptions lookup $tableID pref $preference
}


# ###### Route setup ########################################################
make-route ()
{
   local tableID="$1"             # Table ID
   local destination="$2"         # Destination network
   local interface="$3"           # Output interface
   local nextHop="$4"             # Next hop
   shift ; shift ; shift ; shift
   local miscOptions="$@"         # Misc options (e.g. "----add-to-exiting-tunnel")

   # echo ip route add $destination via $nextHop dev $interface table $tableID $miscOptions
   ip route add $destination via $nextHop dev $interface table $tableID $miscOptions
}
