#!/bin/bash
#
# Routing Setup Functions
# Copyright (C) 2012 by Thomas Dreibholz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: dreibh@simula.no
#


# NOTE:
# Only 8 TOS field settings allowed (remaining bits masked out!)
# This is a bug in the Linux kernel!
# T0 -> 0x00
# T1 -> 0x04
# T2 -> 0x08
# T3 -> 0x0C
# T4 -> 0x10
# T5 -> 0x14
# T6 -> 0x18
# T7 -> 0x1C


# ###### Write log information ##############################################
log ()
{
   echo -e "\x1b[1;34m`date +%FT%H:%M:%S`: $@\x1b[0m"
}


# ###### Write log action information #######################################
log-action ()
{
   echo -en "\x1b[34m`date +%FT%H:%M:%S`: $@\x1b[0m"
}



# ###### Write log result information #######################################
RESULT_GOOD=1
RESULT_BAD=0
_BadResults=0
log-result ()
{
   local result="$1"
   local line=120

   if [ "$result" = "$RESULT_GOOD" ] ; then
      echo -en "\x1b[${line}G\x1b[32mOK\x1b[0m\n"
   elif [ "$result" = "$RESULT_BAD" ] ; then
      echo -en "\x1b[${line}G\x1b[30;47;5mFAILED!\x1b[0m\n"
      let _BadResults=$_BadResults+1
   elif [ "$result" = "" ] ; then
      echo >&2 "ERROR: No result given for log-result?!"
      exit 1
   else
      echo -en "\x1b[${line}G\x1b[0m$result\n"
   fi
}


# ###### Exit with error ####################################################
log-bad-result-and-exit ()
{
   log-result $RESULT_BAD
   exit 1
}


# ###### Exit with result ###################################################
exit-with-result ()
{
   if [ $_BadResults -eq 0 ] ; then
      exit 0
   else
      exit 1
   fi
}


# ###### Log summary and exit with result ###################################
log-summary-and-return-result ()
{
   if [ $_BadResults -eq 0 ] ; then
      log-result $RESULT_GOOD
      return 0
   else
      log-result $RESULT_BAD
      _BadResults=0
      return 1
   fi
}


# ###### Log summary ########################################################
log-summary ()
{
   log-summary-and-return-result || true
}


# ###### Check whether any interface has a given address configured #########
check-local-address ()
{
   local addressToFind="$1"

   addressList=""
   if [[ "$addressToFind" =~ : ]] ; then
      addressList=`ip -6 addr show | awk '/[ \t]*inet6 [0-9a-fA-F:]*\/[0-9]+ scope [gsh]/ { print $2 }' | sed -e "s/\/[0-9]*//g"`
   else
      addressList=`ip -4 addr show | awk '/[ \t]*inet ([0-9]+).([0-9]+).([0-9]+).([0-9]+)\/([0-9]+) / { print $2 }' | sed -e "s/\/[0-9]*//g"`
   fi

   for address in $addressList ; do
      if [ "$address" = "$addressToFind" ] ; then
         return 1
      fi
   done
   return 0
}


# ###### Tunnel removal #####################################################
remove-tunnel ()
{
   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local tunnelKey="$2"           # Tunnel key, must be unique between sites

   ip tunnel del $interface 2>/dev/null || true
}


# ###### Tunnel setup #######################################################
make-tunnel ()
{

   #let xx=$xx+1
   #if [ $xx -eq 4 ] ; then
   #   echo "--- TEST ERROR ---"
   #   xx=1
   #   return 1
   #fi


   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local tunnelKey="$2"           # Tunnel key, must be unique between sites
   local outerLocalIP="$3"        # Outer Local IP
   local outerRemoteIP="$4"       # Outer Remote IP
   local innerLocalIP="$5"        # Inner Local IP
   local innerRemoteIP="$6"       # Inner Remote IP
   local miscOptions="$7"         # Further options

   local innerV6option=""
   local outerV6option=""
   if [[ "$innerLocalIP" =~ : ]] ; then
      innerV6option="-6"
   fi
   if [[ "$outerLocalIP" =~ : ]] ; then
      outerV6option="-6"
   fi

   local mode=""
   local greoption=""
   if [[ "$interface" =~ ^seks ]] ; then
      mode="any"
   elif [[ "$interface" =~ ^fire ]] ; then
      mode="sit"
   elif [[ "$interface" =~ ^gre ]] ; then
      mode="gre"
      greoption="key $tunnelKey"
   else
      echo >&2 "ERROR: Cannot determine tunnel mode from interface name $interface!"
      exit 1
   fi

   local addToExistingTunnel=0
   local v6linklocal=""
   if [[ "$miscOptions" =~ --add-to-existing-tunnel ]] ; then
      addToExistingTunnel=1
   elif [[ "$miscOptions" =~ (--v6-linklocal)([ \t]*)([a-fA-F0-9:./]*)$ ]] ; then
      v6linklocal="${BASH_REMATCH[3]}"
   fi

   # ====== Tunnel setup ====================================================
   success=1
   # Create the tunnel
   # echo "$interface: tunnel [$innerLocalIP <-> $innerRemoteIP] via [$outerLocalIP <-> $outerRemoteIP]"
   if check-local-address "$outerLocalIP" ; then
      echo -e "\n$outerLocalIP is not a local address! Something is wrong!"
      success=0
   fi
   if [ $addToExistingTunnel -eq 0 ] ; then
      remove-tunnel "$interface" "$tunnelKey" "$from" "$tos" "$fwmark"
      ip $outerV6option tunnel add $interface mode $mode local $outerLocalIP remote $outerRemoteIP ttl 255 $greoption $tunnelOptions || success=0
   fi
   ip link set dev $interface up
   # Set IPv6 link-local address manually
   # NOTE: snmpd assumes IPv6 addresses to be unique. GRE tunnels will have non-unique link-local addresses.
   #       Therefore, snmpd complains about (error on subcontainer 'ia_addr' insert (-1))
   #       Solution: Add new link-local address (unique) and remove automatically-generated one.
   if [ "$v6linklocal" != "" ] ; then
      ADDRESSES=`ip -6 addr show dev $interface | awk '/[ \t]*inet6 [0-9a-fA-F:]*\/[0-9]+ scope [l]/ { print $2 }'`
      ip -6 addr add dev $interface $v6linklocal
      for address in $ADDRESSES ; do
         ip -6 addr del $address dev $interface   # Get rid of the automatically-generated address.
      done
   fi
   # Configure an address and turn the interface up
   if [ "$innerV6option" = "" ] ; then
      ip addr add $innerLocalIP peer $innerRemoteIP dev $interface || success=0
   else
      ip $innerV6option addr add $innerLocalIP/64 dev $interface || success=0
   fi
   ip link set dev $interface up
   # Turn off Reverse Path filtering, since it prevents routing packets
   # from interface when this interface has no route to the source!
   sysctl -q net.ipv4.conf.$interface.rp_filter=0 || success=0
   # Also, turn off Reverse Path filter on all interfaces.
   # If it is turned on, it supersedes all per-interface settings!
   sysctl -q net.ipv4.conf.all.rp_filter=0 || success=0

   if [ $success -ne 1 ] ; then
      return 1
   fi
}


# ###### Check tunnel #######################################################
show-tunnel ()
{
   local interface="$1"           # Interface name (fire*, seks*, gre*)
   local innerLocalIP="$2"        # Inner Local IP
   local innerRemoteIP="$3"       # Inner Remote IP
   local description="$4"         # Description

   # echo -en "Pinging $innerRemoteIP (peer on interface $interface) ..."

   success=0
   if [[ "$innerRemoteIP" =~ : ]] ; then
      ping6 -w3 -c1 -i0.2 -q $innerRemoteIP -I $innerLocalIP >/dev/null 2>&1 && success=1
   else
      ping -w3 -c1 -i0.2 -q $innerRemoteIP -I $innerLocalIP >/dev/null 2>&1 && success=1
   fi

   if [ $success -eq 1 ] ; then
      return 0
   else
      return 1
   fi
}


# ###### Address removal ####################################################
remove-address ()
{
   local interface="$1"           # Interface
   local address="$2"             # Address with network prefix (e.g. 10.1.1.1/24)

   local v6option=""
   if [[ "$address" =~ : ]] ; then
      v6option="-6"
   fi

   while ip $v6option addr del $address dev $interface 2>/dev/null ; do
      dummy=1
   done
}


# ###### Address setup ######################################################
make-address ()
{
   local interface="$1"           # Interface
   local address="$2"             # Address with network prefix (e.g. 10.1.1.1/24)

   local v6option=""
   if [[ "$address" =~ : ]] ; then
      v6option="-6"
   fi

   remove-address $interface $address
   ip $v6option addr add $address dev $interface
   ip link set up dev eth0
}


# ###### Routing table removal ##############################################
remove-table ()
{
   local tableID="$1"             # Table ID

   # ====== Remove routing table ============================================
   ip route flush table $1

   # ====== Remove all rules pointing to that table =========================
   ip rule show | (
     while read inputLine ; do
         if [[ $inputLine =~ ([0-9]*):(.*)([ \t]*lookup ${tableID}[ \t]*)$ ]]; then
            if [ ${#BASH_REMATCH[*]} -eq 4 ] ; then
               pref=${BASH_REMATCH[1]}
               rule=${BASH_REMATCH[2]}
               lookup=${BASH_REMATCH[3]}
               ip rule del $rule ${lookup} pref $pref
            fi
        fi
     done
   )
}


# ###### Routing table setup ################################################
make-table ()
{
   local tableID="$1"             # Table ID

   remove-table $tableID
}


# ###### Add or remove selector for routing table ###########################
add-or-remove-table-selector ()
{
   local action="$1"              # Action ("add" or "remove")
   local tableID="$2"             # Table ID
   local preference="$3"          # Selected preference
   shift ; shift ; shift

   local v6option=""
   local selectorOptions=""
   while [ "$1" != "" ] ; do
      if [ "$1" = "not" ] ; then
         selectorOptions="$selectorOptions not"
      elif [ "$1" = "from" ] ; then
         selectorOptions="$selectorOptions from $2"
         if [[ "$2" =~ : ]] ; then
            v6option="-6"
         fi
         shift
      elif [ "$1" = "to" ] ; then
         selectorOptions="$selectorOptions to $2"
         if [[ "$2" =~ : ]] ; then
            v6option="-6"
         fi
         shift
      elif [ "$1" = "tos" ] ; then
         selectorOptions="$selectorOptions tos $2"
         shift
      elif [ "$1" = "fwmark" ] ; then
         selectorOptions="$selectorOptions fwmark $2"
         shift
      else
         echo >&2 "ERROR: Unknown selector "$1"!"
         exit 1
      fi
      shift
   done

   if [ "$action" = "del" ] ; then
      ip $v6option rule del $selectorOptions lookup $tableID pref $preference 2>/dev/null || true
   else
      ip $v6option rule $action $selectorOptions lookup $tableID pref $preference
   fi
}


# ###### Add selector for routing table #####################################
add-table-selector ()
{
   add-or-remove-table-selector add $@
}


# ###### Remove selector for routing table ##################################
remove-table-selector ()
{
   add-or-remove-table-selector del $@
}


# ###### Route setup ########################################################
make-route ()
{
   local tableID="$1"             # Table ID
   local destination="$2"         # Destination network
   local interface="$3"           # Output interface
   local nextHop="$4"             # Next hop
   shift ; shift ; shift ; shift
   local miscOptions="$@"         # Misc options (e.g. "----add-to-exiting-tunnel")

   # echo ip route add $destination via $nextHop dev $interface table $tableID $miscOptions
   ip route add $destination via $nextHop dev $interface table $tableID $miscOptions
}


# ###### Add Source NAT rule ################################################
make-nat ()
{
   local sourceNetwork="$1"       # Source network (e.g. 10.0.0.0/8)
   local range="$2"               # Public IP range (optional)

   remove-nat "$sourceNetwork" "$range"
   if [ "$range" = "" ] ; then
      iptables -t nat -A POSTROUTING -s "$sourceNetwork" -j MASQUERADE
   else
      iptables -t nat -A POSTROUTING -s "$sourceNetwork" -j SNAT --to-source "$range"
   fi
}


# ###### Add Source NAT rule ################################################
remove-nat ()
{
   local sourceNetwork="$1"       # Source network (e.g. 10.0.0.0/8)
   local range="$2"               # Public IP range (optional)

   if [ "$range" = "" ] ; then
      while iptables -t nat -D POSTROUTING -s "$sourceNetwork" -j MASQUERADE 2>/dev/null ; do
         dummy=1
      done
   else
      while iptables -t nat -D POSTROUTING -s "$sourceNetwork" -j SNAT --to-source "$range" 2>/dev/null ; do
         dummy=1
      done
   fi
}


# ###### Check whether a provider is in a list of available providers #######
checkProviders () {
   local availableProviders="$1"
   local selectedProviders="$2"
   local oldIFS=$IFS
   IFS=","
   if [ "$selectedProviders" != "*" ] ; then
      for b in $selectedProviders ; do
         found=0
         for a in $availableProviders ; do
            if [ "$a" == "$b" ] ; then
               found=1
            fi
         done
         if [ $found -eq 0 ] ; then
            echo >&2 "ERROR: Provider \"$b\" is not in the list of available providers \"$availableProviders\"!"
            exit 1
         fi
      done
   fi
   IFS=$oldIFS
}
